
// function playerStart () {
//   //Update boardState
//   let boardKey = `b${zelda.row}${zelda.col}`
//   //console.log(boardKey)
//   boardState[boardKey].objectOnLoc = zelda
//   //console.log(boardState[boardKey])
//   //Update HTML
//   document.getElementById(`${zelda.row}${zelda.col}`).innerHTML = zelda.nam
// }

// function monsterStart () {
//   //Update boardState
//   let boardKey = `b${monster1.row}${monster1.col}`
//   //console.log(boardKey)
//   boardState[boardKey].objectOnLoc = monster1
//   //console.log(boardState[boardKey]) 
//   //Update HTML
//    document.getElementById(`${monster1.row}${monster1.col}`).innerHTML = monster1.nam
// }

  //  //Set player combat attack to monster health or max player attack, whichever is lower; set attacker and defender combat values
  // let playerCombatAttack
  // let aCombatAttack
  // let dCombatAttack

  // if (attacker.typ == `player`) {
  //   dInitialLif < attacker.atk ? playerCombatAttack = dInitialLif : playerCombatAttack = attacker.atk
  //   aCombatAttack = playerCombatAttack
  //   dCombatAttack = defender.atk
  // } else {
  //   attacker.lif < defender.atk ? playerCombatAttack = attacker.lif : playerCombatAttack = defender.atk
  //   dCombatAttack = playerCombatAttack
  //   aCombatAttack = attacker.atk
  // }


        display: grid;
        grid-template-columns: 1fr 1fr;
        grid-template-rows: 1fr 1fr;
        column-gap: 3px;
        row-gap: 3px;
        align-items: center;
        justify-items: center;

<img class="game-board-pic" src="/Assets/TLoZ_Princess_Zelda_Sprite.png">


9/25 Standup Notes
So far...
- Built out gameboard
- Built out logic to have player move every turn (single space, within boarders) 
- Built out logic to have monster move every other turn (single space, within boarders) 
- Used API to create "databases" of

9/26 Standup Notes...
- Issues
    - Git sync - forking issues, don't want to lose work
    - How do you run an async function completely before the rest of the code runs?
- For today
    - Finalize/test V1 game logic, gameplay via console
    - Create initial UI, including title, gameboard, turn status, player stats, and new game button
- Remainder of the week
    - CSS cleanup
    - V2+ time permitting

9/27 Standup Notes
- For today 
    - (1 hour, time boxed) Grid layers on character icons/stats
    - Code and CSS for messages/status box
    - game over function and screen popup
    - (stretch) new game function and screen popup
- Remainder of the week
    - CSS cleanup
    - V2+ time permitting



// //monster - Name, Type, Attack, Defence, Row Location, Column Location
// const monster1 = {
//   name: `Ganon`,
//   category: `monster`,
//   atk: 20,
//   maxLife: 5,
//   lif: 5,
//   def: 0,
//   row: 5,
//   col: 5,
//   image: "/Assets/BotW_Dark_Beast_Ganon_Model.png"
// }

// //weapon - Name, Type, Attack, Row Location, Column Location
// const sword1 = {
//   name: `Great Frostblade`,
//   category: `weapon`,
//   atk: 1,
//   row: 2,
//   col: 3,
//   image: "https://botw-compendium.herokuapp.com/api/v3/compendium/entry/great_frostblade/image"
// }

// const sword2 = {
//   name: `Forest Dweller's Spear`,
//   category: `weapon`,
//   atk: 1,
//   row: 4,
//   col: 5,
//   image: "https://botw-compendium.herokuapp.com/api/v3/compendium/entry/forest_dweller's_spear/image"
// }

// const sword3 = {
//   name: `Soldier Spear`,
//   category: `weapon`,
//   atk: 1,
//   row: 5,
//   col: 4
// }
# R1 Prototype
- Grid - 6x6
- Single/fixed-stats objects
  - Monster (1 atk, 2 health)
  - Sword (2 atk)
  - Player (0 atk, 3 health)
- Game Data
  - Player
    - Attack
    - Health
  - Weapon
    - Attack
  - Monster
    - Attack
    - Health
- Mechanics
  - Movement
  - Combat (including multi-combat)
  - Turn Count
- QA/Success Criteria
  - Valid turn order - Player -> Monster
  - Valid movement - Player
    - Player moves from keyboard/mouse
    - Cannot exit grid
    - Movement limited to one square up/down/left/right
  - Valid movement - Monster
    - Random Movement
    - Cannot exit grid
    - Movement limited to one square up/down/left/right
  - Player moves to sword location
    - Sword Disappears
    - Player Attack Stats are increased by sword attack value
  - Valid Combat
    - Attacker initiates
    - Combat repeats until character health is <1

# R2 Additional Mechanics
- Single/fixed stats objects
  - Shield
  - Food
  - Fairy
  - Treasure
  - Heart Container
- Mechanics
  - Shield Consume/Break
  - Food consume/health increase
  - Heart consume/ increase health container count

# R3 
  - 


  <h1> Welcome to Zelda RPH </h1>
  <p></p>


  START
    turn=0

  Click 
    player
    



    Things I didn't get to:
    - Mechanics:
      - Stats balancing
      - Alternate terrains
      - Additional Items (fairies, treasure, etc.)
      - "Smart" item selection (e.g., monsters get stronger at later turns)
      - Holding multiple items; selecting them before taking a turn
      - Link movement (similar to monster movement?)
    - Other Functionality
      - Game summary stats (e.g., monsters killed, items collected)
      - Local host stats
      - Directly linking to URL images (e.g., from Zelda Wiki)
      - Using keyboard entry (WASD, Arrow) in addition to Clicks
      - More game stuff - dialogue/story, boss battle, link fishing mini-game
     -Look and Feel
      - Movement and combat animations
      - Scrolling status box that keeps the full game's updates, defaulting to showing the recently added text. https://css-tricks.com/books/greatest-css-tricks/pin-scrolling-to-bottom/
      - Better dynamic Resizing (putting alert bus and stats box underneath the gameboard at lower screen widths)
      - Better backgrounds/aesthetics for:
        - Board Squares (rounded corners, background image or texture on empty space)
        - Character Images + Enbedded Character Data
        - Major Containers (currently very blocky)
    
    Challenges
    - Dynamic Sizing - You cannot restrict height in basic HTML/CSS. I ended up using cascading CSS Grid, but it's still a bit wonky
    - Getting my API to finish running before doing anything else. Finally figured it out here - https://stackoverflow.com/questions/21518381/proper-way-to-wait-for-one-function-to-finish-before-continuing
    - Game logic complexity - debugging took forever on each issue. Weird interactions included
      - Gamestate when monster initiates combat
      - Sequencing between player turn, monster turn, and updating game state

    Biggest Successes
    - Dynamic sizing with CSS Grid
    - API Async/await
    - Dynamically building/deleting HTML with <span> formatting.
    - Layered images with z-index
    - Complex API dataset, integrating two data sets
    - Complex, function-driven game logic:
      - 25+ functions with parameters and nested calls
      - For and forEach loops on arrays and objects
      - If/Switch all over the place
    - Notable functions and functionality
      - gameSquares.forEach('click')
        - Logs the gamesquare location on the gameboard when the square is clicked, initiaties turn sequence
      - playerTurn(clickedLocation)
        - Check if the location is a valid move
        - Depending on the object in the target location:
          - Initiate Combat
          - Consume Items
          - Move to empty space
        - execute the move and update player stats
      - mosterTurn(monster) Loop - For each monster on the board, every other turn:
        - Pick a random and legal move using getValidRandomMoves()
        - Depending on the object in the target location:
          - Initiate Combat
          - Consume Items
          - Move to empty space
      - playerCombat (attacker, defender)
        - log initial character stats
        - while loop for rounds of combat while both characters are alive
        - If player wins (player.lif > 0)
          - Update player stats based on initial character stats
          - delete/remove monster
        - Show combat outcome in status log
      - randomMonstersEquipment()
        - pull a random monster, 2 random shields, and 2 random weapons objects from the API List
        - place the random monster in a random valid location
        - place the random weapons/shields in valid surrounding spaces
      - executeValidMove(character, futureRow, futureColumn)
        - hold initial location state in temporary variables
        - clear initial boardState and related HTML
        - update boardState and related HTML
      - renderObject(character, row, column) - 
        - character{} contains object characteristics
        - Update HTML on a specific gameboard square based on character{} data if available and related icons:
          - Background Image
          - Category icon
          - Name
          - attack Stats
          - defence stats
          - life

    Biggest Takeaways
    - CSS is not as hard as I thought it was, but I still don't like it
    - I now understand why game engines are a thing

    - If I did it again... 
      - Spend more time on CSS and less time on complex code; don't be afraid of screen @media and fixed sizes
      - Explore other front-end functionality (e.g., open new pages)
      - More/better use of string functions and other efficient code
      - Be even more diligent about documenting "sprints" "test cases" and other work management
      - Do the easy stuff first, even if it's boring!